<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
<link href="https://cdn.bootcss.com/twitter-bootstrap/4.1.0/css/bootstrap.min.css" rel="stylesheet"/>
<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/popper.js/1.12.9/popper.min.js"></script>
<script src="https://cdn.bootcss.com/twitter-bootstrap/4.1.0/js/bootstrap.min.js"></script>
<link href="/img/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="/img/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<title>ZimingYuan的博客首页（第2页）</title>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-light sticky-top">
<div class="container">
<a class="navbar-brand" href="#">ZimingYuan的博客</a>
<div class="navbar-collapse">
<ul class="navbar-nav">
<li class="nav-item active">
<a class="nav-link" href="/index.html">首页</a>
</li>
<li class="nav-item active">
<a class="nav-link" href="/html/随笔.html">随笔</a>
</li>
<li class="nav-item active">
<a class="nav-link" href="/html/CSP模板.html">CSP模板</a>
</li>
</ul>
</div>
</div>
</nav>
<div class="container p-4">
<div class="row">
<div class="col-9" id="Bloglist">
<div class="card shadow mb-4">
<h5 class="card-header">
<a href="/html/MIT-6.S081-2020实验（xv6-riscv64）十：mmap.html">MIT-6.S081-2020实验（xv6-riscv64）十：mmap</a>
</h5>
<div class="card-body">
<h5 class="card-title">摘要：</h5>
<p class="card-text">实验文档 概述 这次实验要求实现Linux中的mmap函数的一个子集，相当于在第五次实验Lazy Allocation中加上了文件的操作。难度比较难定义，因为这个“子集”还是比较模糊的，如果仅仅只针对测试程序，做出一些简化性的假设，难度就不会太大，但如果不做这些假设，难度就会非常高。 内容 为了简化</p>
<h6 class="card-subtitle text-muted text-right">2021年1月13日</h6>
</div>
</div>

<div class="card shadow mb-4">
<h5 class="card-header">
<a href="/html/MIT-6.S081-2020实验（xv6-riscv64）九：fs.html">MIT-6.S081-2020实验（xv6-riscv64）九：fs</a>
</h5>
<div class="card-body">
<h5 class="card-title">摘要：</h5>
<p class="card-text">实验文档 概述 这次实验涉及文件系统，重点是对inode节点的操作。 内容 Large files 这个任务主要目的是支持更大的文件。和内存映射类似，文件系统中也有一个类似“页表”的结构，每个文件（inode）都有自己的一个“页表”，维护自己文件占用的文件块。和内存不同的是，这个“页表”的级别是自定</p>
<h6 class="card-subtitle text-muted text-right">2021年1月11日</h6>
</div>
</div>

<div class="card shadow mb-4">
<h5 class="card-header">
<a href="/html/MIT-6.S081-2020实验（xv6-riscv64）八：lock.html">MIT-6.S081-2020实验（xv6-riscv64）八：lock</a>
</h5>
<div class="card-body">
<h5 class="card-title">摘要：</h5>
<p class="card-text">实验文档 概述 这次实验主要涉及锁在内核的应用，没有用到什么特别的理论知识，但是编程的时候陷阱重重，要么资源竞争，要么死锁，和实验三差不多，非常考验耐心和细心。 内容 Memory allocator 这个任务要求给物理内存分配程序重新设计锁，使得等待锁时的阻塞尽量少。可以按CPU的数量将空闲内存分</p>
<h6 class="card-subtitle text-muted text-right">2021年1月8日</h6>
</div>
</div>

<div class="card shadow mb-4">
<h5 class="card-header">
<a href="/html/MIT-6.S081-2020实验（xv6-riscv64）七：thread.html">MIT-6.S081-2020实验（xv6-riscv64）七：thread</a>
</h5>
<div class="card-body">
<h5 class="card-title">摘要：</h5>
<p class="card-text">实验文档 概述 这次实验主要涉及多线程编程，和之前的实验不太一样，比较偏向于应用层面，除了任务一外都是在宿主机上编写多线程程序，应该是xv6不支持系统级的多线程。 内容 Uthread: switching between threads 这个任务要求对一个程序填空，这个程序在用户层面实现了多线程的</p>
<h6 class="card-subtitle text-muted text-right">2021年1月6日</h6>
</div>
</div>

<div class="card shadow mb-4">
<h5 class="card-header">
<a href="/html/MIT-6.S081-2020实验（xv6-riscv64）六：cow.html">MIT-6.S081-2020实验（xv6-riscv64）六：cow</a>
</h5>
<div class="card-body">
<h5 class="card-title">摘要：</h5>
<p class="card-text">实验文档 概述 这次实验实现copy on write功能，和上次实验一样也是缺页中断的应用，但不同的是，这次实验涉及的物理内存和虚拟地址的操作要比上个实验多不少，因此难度也更大一些。 内容 首先是uvmcopy的部分，原来的操作是从老页表中获得虚拟地址对应的物理地址，创建一个新物理页，然后将老物理</p>
<h6 class="card-subtitle text-muted text-right">2021年1月6日</h6>
</div>
</div>

<div class="card shadow mb-4">
<h5 class="card-header">
<a href="/html/MIT-6.S081-2020实验（xv6-riscv64）五：lazy.html">MIT-6.S081-2020实验（xv6-riscv64）五：lazy</a>
</h5>
<div class="card-body">
<h5 class="card-title">摘要：</h5>
<p class="card-text">实验文档 概述 这次实验主要实现Lazy allocation的功能，即进程在动态分配内存的时候先不分配，等到要用到发生缺页中断的时候再实际分配，核心是实现缺页中断的处理。xv6的文档介绍了三种缺页中断的应用，第一为Copy on write，即fork的时候先不复制内存，等到要用到发生缺页中断的时</p>
<h6 class="card-subtitle text-muted text-right">2021年1月2日</h6>
</div>
</div>

<div class="card shadow mb-4">
<h5 class="card-header">
<a href="/html/MIT-6.S081-2020实验（xv6-riscv64）四：traps.html">MIT-6.S081-2020实验（xv6-riscv64）四：traps</a>
</h5>
<div class="card-body">
<h5 class="card-title">摘要：</h5>
<p class="card-text">实验文档 概述 这次实验内容比较分散，总体来说难度不是太高。 内容 Backtrace 要求在内核中对程序的调用栈进行遍历，输出每一级调用的返回地址。首先我们分析Riscv的栈帧结构，查看call.asm中main函数的汇编代码： void main(void) { 1c: 1141 addi sp</p>
<h6 class="card-subtitle text-muted text-right">2021年1月1日</h6>
</div>
</div>

<div class="card shadow mb-4">
<h5 class="card-header">
<a href="/html/MIT-6.S081-2020实验（xv6-riscv64）三：pgtbl.html">MIT-6.S081-2020实验（xv6-riscv64）三：pgtbl</a>
</h5>
<div class="card-body">
<h5 class="card-title">摘要：</h5>
<p class="card-text">实验文档 概述 这次实验主要涉及虚拟内存的管理，重点是和页表相关的操作。个人觉得难点主要还是在调试方面，因为一旦写到什么非法内存或者哪里内存泄漏了，基本只能抓瞎。我也是参考了github上别人的代码才最终完成了实验。 内容 Print a page table 这个任务比较简单，只要仿照freewa</p>
<h6 class="card-subtitle text-muted text-right">2020年12月31日</h6>
</div>
</div>

<div class="card shadow mb-4">
<h5 class="card-header">
<a href="/html/MIT-6.S081-2020实验（xv6-riscv64）二：syscall.html">MIT-6.S081-2020实验（xv6-riscv64）二：syscall</a>
</h5>
<div class="card-body">
<h5 class="card-title">摘要：</h5>
<p class="card-text">实验文档 概述 实验二主要涉及对系统函数调用过程的理解以及尝试自己手动添加系统调用。首先需要大致了解一下xv6系统调用的过程，这里以fork为例： 根据这个过程，就很容易完成本次实验了。 内容 trace 该实验需要打印其他系统调用的信息。根据上面的分析和文档说明，首先需要给user.h、usys.</p>
<h6 class="card-subtitle text-muted text-right">2020年12月31日</h6>
</div>
</div>

<div class="card shadow mb-4">
<h5 class="card-header">
<a href="/html/MIT-6.S081-2020实验（xv6-riscv64）一：util.html">MIT-6.S081-2020实验（xv6-riscv64）一：util</a>
</h5>
<div class="card-body">
<h5 class="card-title">摘要：</h5>
<p class="card-text">实验文档 概述 实验一主要涉及调用系统调用函数，这些系统调用函数基本都是符合POSIX规范的，和操作系统本身关系较小，在调试的时候也可以先把程序在外部的Linux下跑通然后再放进xv6中运行。 内容 sleep 基本没什么特别的内容，按说明的做就行了。 #include &amp;quot;kernel/types.</p>
<h6 class="card-subtitle text-muted text-right">2020年12月31日</h6>
</div>
</div>

<ul class="pagination justify-content-center">
<li class="page-item" id="previous">
<a class="page-link" href="/index.html">上一页</a>
</li>
<li class=""><a class="page-link" href="/index.html">1</a></li><li class="page-item active"><a class="page-link" href="/index/2.html">2</a></li><li class=""><a class="page-link" href="/index/3.html">3</a></li><li class=""><a class="page-link" href="/index/4.html">4</a></li><li class=""><a class="page-link" href="/index/5.html">5</a></li><li class="page-item" id="next">
<a class="page-link" href="/index/3.html">下一页</a>
</li>
</ul>
</div>
<div class="col">
<div class="card shadow mb-4">
<h5 class="card-header text-center">
                            关于我
                        </h5>
<div class="card-body">
<img class="card-img-top" src="/img/favicon.ico"/>
<p class="card-text">前偏远小渔村边缘OIer，现在是HUST计院普通大学生。</p>
<p class="card-text">
<a href="https://github.com/ZimingYuan" target="_BLANK">Github</a>
                                Gitee上也有同名账户，同步大部分项目。
                            </p>
<p class="card-text">
                                该博客为
                                <a href="https://www.cnblogs.com/YuanZiming/" target="_BLANK">我的博客园</a>
                                的备份，原博客有过去的一些文章以及细致的文章分类。
                            </p>
</div>
</div>`;
                </div>
</div>
</div>
<span class="bg-light text-muted border boder-primary d-block p-2 text-center">
            转载请注明出处<br/>
            © 2021 ZimingYuan的博客
        </span>
<div style="background-color: #ebd5a1; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; pointer-events: none; opacity: 0.2;">
</div>
</body>
</html>
