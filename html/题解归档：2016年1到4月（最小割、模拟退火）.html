<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN" data-theme="tufte">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/extra/classless.css" />
<style>
html[data-theme='tufte']{
    --rem: 15px;
    --navpos: absolute;
    --width: 70rem;
    --font-p: 1.4rem/2 et-book, Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
    --font-h: 1.4rem/1.5 et-book, Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
    --font-c: .9em/1.4 Consolas,"Liberation Mono","Courier New",monospace;
    --ornament: "";
    --border: 1px solid var(--cmed);
    /* foreground   | background color */
    --cfg:   #111;    --cbg:    #fbf7ec;
    --cdark: #111;    --clight: #fbf7ec;
    --cmed: #b4d5fe;
    --clink: #111;
    --cemph: #111;
}
</style>
  <script>
      let search = () => {
          let word = document.querySelector('input');
          if (word.value.length == 0) {
              word.focus();
          } else {
              location.href = '/search.html?' + word.value;
          }
      };
      window.onload = () => {
          document.querySelector('input').addEventListener(
              'keydown',  (event) => {
                  if (event.key == 'Enter') search();
          });
      }
  </script>
  <link rel="icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <title>题解归档：2016年1到4月（最小割、模拟退火）</title>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <nav>
        <ul>
            <li><big>VnYzm的博客</big></li>
            <li><a href="/index.html">主页</a></li>
            <li><a href="/html/随笔.html">随笔</a></li>
            <li><a href="/miscellany.html">杂谈</a></li>
            <li class="float-right sticky"><button style="margin: 0" onclick="search()">Go</button></li>
            <li class="float-right sticky"><input type="search" placeholder="搜索" style="margin: 0"></li>
        </ul>
    </nav>
<header id="title-block-header">
<h1 class="title">题解归档：2016年1到4月（最小割、模拟退火）</h1>
<hr>
</header>
<h3 id="bzoj1412zjoi2009狼和羊的故事2016.1.2">bzoj1412[ZJOI2009]狼和羊的故事（2016.1.2）</h3>
<h4 id="题意">题意</h4>
<p>n*m网格，每个格子可能为狼、羊或空格。现在要在一些格子边界篱笆使羊狼分开，求最短篱笆。n，m≤100</p>
<h4 id="题解">题解</h4>
<p>最小割问题，建一个超级源和超级汇，然后从源点向每只羊之间连边，容量为正无穷；每只狼向汇点连边，容量为正无穷，相邻格子之间连边，容量为1，再跑一次最大流就是结果。因为每一条同时经过羊和狼的路径都需要堵住，但又不能堵连向源点和汇点的边，所以堵住的边必定是将羊和狼分隔开的边。</p>
<p>dicnic：求解网络流的一种算法：先用bfs构建层次图，然后用dfs沿着层次增广，当dfs无法增广时再重复上述过程，知道源点和汇点不连通。速度比传统的EK法要快得多，但比ISAP慢，因为ISAP无法增广时是直接修改层次，同时还能用gap优化，但dicnic很好写，简洁易懂。CZL大爷说dicnic在计算本来就有一定层次的图（如二分图）时速度快，ISAP在计算一般图速度快，涨姿势了！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="pp">#define INF </span><span class="bn">0xfffffff</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="pp">#define g</span>(b)<span class="pp"> </span>g[b.x][b.y]</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="pp">#define h</span>(b)<span class="pp"> </span>h[b.x][b.y]</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="pp">#define maxn </span><span class="dv">110</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="co">//edge</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="kw">struct</span> p{<span class="dt">int</span> x,y;}; <span class="kw">struct</span> e{p t;<span class="dt">int</span> c,n;}; e es[<span class="dv">200000</span>*<span class="dv">2</span>]; <span class="dt">int</span> ess,g[maxn][maxn];</span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="dt">void</span> pe(p f,p t,<span class="dt">int</span> c){</span>
<span id="cb1-15"><a href="#cb1-15"></a>    es[++ess]=(e){t,c,g(f)}; g(f)=ess;</span>
<span id="cb1-16"><a href="#cb1-16"></a>    es[++ess]=(e){f,<span class="dv">0</span>,g(t)}; g(t)=ess;</span>
<span id="cb1-17"><a href="#cb1-17"></a>}</span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="co">//maxflow</span></span>
<span id="cb1-20"><a href="#cb1-20"></a>queue &lt;p&gt; q; <span class="dt">int</span> h[maxn][maxn];</span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="dt">bool</span> bfs(p s,p t){<span class="co">//构建层次图</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="cf">while</span>(! q.empty())q.pop(); memset(h,-<span class="dv">1</span>,<span class="kw">sizeof</span>(h)); h(s)=<span class="dv">0</span>; q.push(s);</span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb1-24"><a href="#cb1-24"></a>        p now=q.front(); q.pop();</span>
<span id="cb1-25"><a href="#cb1-25"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g(now);i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(h(es[i].t)==-<span class="dv">1</span>&amp;&amp;es[i].c&gt;<span class="dv">0</span>){</span>
<span id="cb1-26"><a href="#cb1-26"></a>            h(es[i].t)=h(now)+<span class="dv">1</span>; q.push(es[i].t);</span>
<span id="cb1-27"><a href="#cb1-27"></a>        }</span>
<span id="cb1-28"><a href="#cb1-28"></a>    }</span>
<span id="cb1-29"><a href="#cb1-29"></a>    <span class="cf">return</span> (h(t)==-<span class="dv">1</span>)?<span class="dv">0</span>:<span class="dv">1</span>;</span>
<span id="cb1-30"><a href="#cb1-30"></a>}</span>
<span id="cb1-31"><a href="#cb1-31"></a><span class="dt">int</span> dfs(p x,p t,<span class="dt">int</span> flow){<span class="co">//找增广路并增广</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>    <span class="cf">if</span>(x.x==t.x&amp;&amp;x.y==t.y)<span class="cf">return</span> flow;</span>
<span id="cb1-33"><a href="#cb1-33"></a>    <span class="dt">int</span> used=<span class="dv">0</span>;</span>
<span id="cb1-34"><a href="#cb1-34"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g(x);i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&gt;<span class="dv">0</span>&amp;&amp;h(es[i].t)==h(x)+<span class="dv">1</span>){</span>
<span id="cb1-35"><a href="#cb1-35"></a>        <span class="dt">int</span> w=dfs(es[i].t,t,min(flow,es[i].c));</span>
<span id="cb1-36"><a href="#cb1-36"></a>        es[i].c-=w; es[i^<span class="dv">1</span>].c+=w; used+=w; flow-=w; <span class="cf">if</span>(flow==<span class="dv">0</span>)<span class="cf">return</span> used;</span>
<span id="cb1-37"><a href="#cb1-37"></a>    }</span>
<span id="cb1-38"><a href="#cb1-38"></a>    <span class="cf">if</span>(! used)h(x)=-<span class="dv">1</span>; <span class="cf">return</span> used;</span>
<span id="cb1-39"><a href="#cb1-39"></a>}</span>
<span id="cb1-40"><a href="#cb1-40"></a><span class="dt">int</span> dicnic(p s,p t){<span class="dt">int</span> flow=<span class="dv">0</span>; <span class="cf">while</span>(bfs(s,t))flow+=dfs(s,t,INF); <span class="cf">return</span> flow;}</span>
<span id="cb1-41"><a href="#cb1-41"></a></span>
<span id="cb1-42"><a href="#cb1-42"></a><span class="co">//main</span></span>
<span id="cb1-43"><a href="#cb1-43"></a><span class="dt">int</span> n,m,graph[maxn][maxn];</span>
<span id="cb1-44"><a href="#cb1-44"></a><span class="dt">int</span> main(){</span>
<span id="cb1-45"><a href="#cb1-45"></a>    <span class="co">//freopen(&quot;zs.txt&quot;,&quot;r&quot;,stdin);</span></span>
<span id="cb1-46"><a href="#cb1-46"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m);</span>
<span id="cb1-47"><a href="#cb1-47"></a>    inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,m)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;graph[i][j]);</span>
<span id="cb1-48"><a href="#cb1-48"></a>    memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g)); ess=-<span class="dv">1</span>;</span>
<span id="cb1-49"><a href="#cb1-49"></a>    inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,m){</span>
<span id="cb1-50"><a href="#cb1-50"></a>        <span class="cf">if</span>(graph[i][j]==<span class="dv">2</span>)pe((p){<span class="dv">0</span>,<span class="dv">0</span>},(p){i,j},INF);</span>
<span id="cb1-51"><a href="#cb1-51"></a>        <span class="cf">if</span>(graph[i][j]==<span class="dv">1</span>)pe((p){i,j},(p){n+<span class="dv">1</span>,m+<span class="dv">1</span>},INF);</span>
<span id="cb1-52"><a href="#cb1-52"></a>        <span class="cf">if</span>(i-<span class="dv">1</span>&gt;<span class="dv">0</span>)pe((p){i,j},(p){i-<span class="dv">1</span>,j},<span class="dv">1</span>);</span>
<span id="cb1-53"><a href="#cb1-53"></a>        <span class="cf">if</span>(i+<span class="dv">1</span>&lt;=n)pe((p){i,j},(p){i+<span class="dv">1</span>,j},<span class="dv">1</span>);</span>
<span id="cb1-54"><a href="#cb1-54"></a>        <span class="cf">if</span>(j-<span class="dv">1</span>&gt;<span class="dv">0</span>)pe((p){i,j},(p){i,j-<span class="dv">1</span>},<span class="dv">1</span>);</span>
<span id="cb1-55"><a href="#cb1-55"></a>        <span class="cf">if</span>(j+<span class="dv">1</span>&lt;=m)pe((p){i,j},(p){i,j+<span class="dv">1</span>},<span class="dv">1</span>);</span>
<span id="cb1-56"><a href="#cb1-56"></a>    }</span>
<span id="cb1-57"><a href="#cb1-57"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dicnic((p){<span class="dv">0</span>,<span class="dv">0</span>},(p){n+<span class="dv">1</span>,m+<span class="dv">1</span>}));</span>
<span id="cb1-58"><a href="#cb1-58"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-59"><a href="#cb1-59"></a>}</span></code></pre></div>
<h3 id="bzoj2428haoi2006均分数据20160421">bzoj2428[HAOI2006]均分数据（20160421）</h3>
<h4 id="题意-1">题意：</h4>
<p>已知N个正整数，将它们分成M组，使各组数据的数值和最平均，即各组的均方差最小，求最小均方差。</p>
<p><span class="math display">\[
\sigma=\sqrt{\frac{\sum_{i=1}^{n}{(x_i-\overline{x})^2}}{n}}
\]</span></p>
<p><span class="math display">\[
\overline{x}=\frac{\sum_{i=1}^{n}{x_i}}{n}
\]</span></p>
<p>其中<span class="math inline">\(\sigma\)</span>为均方差，<span class="math inline">\(\overline{x}\)</span>是各组数据和的平均值，<span class="math inline">\(x_i\)</span>为第i组数据的数值和。</p>
<h4 id="题解-1">题解</h4>
<p>神奇的模拟退火算法！它是爬山算法的加强版。爬山算法是一种贪心算法，对于每个状态，除非随机选出一个后继状态比它好，才会跳过去。但这样有可能“一叶障目不见泰山”，产生错误的答案。但模拟退火不一样，它如果找到一个后继状态比当前状态差，也有一定概率跳过去，但这概率和跳跃次数成反比。这样即使被“一叶障目”，也有机会绕过叶子，找到泰山。</p>
<blockquote>
<p>关于爬山算法与模拟退火，有一个有趣的比喻： 爬山算法：兔子朝着比现在高的地方跳去。它找到了不远处的最高山峰。但是这座山不一定是珠穆朗玛峰。这就是爬山算法，它不能保证局部最优值就是全局最优值。 模拟退火：兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，它渐渐清醒了并朝最高方向跳去。这就是模拟退火。</p>
</blockquote>
<p>这个算法写法实际上是模拟一个物理降温过程，然而对我这种物理渣~~只能背代码框架了QAQ</p>
<p>回到本题，首先给每个数据随机分到一个组，做5000次模拟退火。当温度比较高时跳跃不稳定，所以贪心一下，随机找一个数据，然后把它放进当前和最小的那个组；当温度渐低后，就随机找一个数据然后随机放组。关于退火的次数，网上题解里是10000，我试过1000会不能过，但是5000能过且比10000要快一倍，所以代码给出的是5000。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="dt">int</span> n,m,pos[<span class="dv">100</span>]; <span class="dt">double</span> a[<span class="dv">100</span>],sum[<span class="dv">100</span>],ave,mn,T,ans,pre;</span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="dt">void</span> solve(){</span>
<span id="cb2-12"><a href="#cb2-12"></a>     memset(sum,<span class="dv">0</span>,<span class="kw">sizeof</span>(sum)); inc(i,<span class="dv">1</span>,n)pos[i]=rand()%m+<span class="dv">1</span>,sum[pos[i]]+=a[i]; ans=<span class="dv">0</span>;</span>
<span id="cb2-13"><a href="#cb2-13"></a>     inc(i,<span class="dv">1</span>,m)ans+=(sum[i]-ave)*(sum[i]-ave); T=<span class="dv">10000</span>;</span>
<span id="cb2-14"><a href="#cb2-14"></a>     <span class="cf">while</span>(T&gt;<span class="fl">0.1</span>){</span>
<span id="cb2-15"><a href="#cb2-15"></a>         pre=ans; <span class="dt">int</span> x=rand()%n+<span class="dv">1</span>,y;</span>
<span id="cb2-16"><a href="#cb2-16"></a>         <span class="cf">if</span>(T&gt;<span class="dv">500</span>)y=min_element(sum+<span class="dv">1</span>,sum+<span class="dv">1</span>+m)-sum;<span class="cf">else</span> y=rand()%m+<span class="dv">1</span>; <span class="cf">if</span>(pos[x]==y)<span class="cf">continue</span>;</span>
<span id="cb2-17"><a href="#cb2-17"></a>         ans-=(sum[pos[x]]-ave)*(sum[pos[x]]-ave); ans+=(sum[pos[x]]-a[x]-ave)*(sum[pos[x]]-a[x]-ave);</span>
<span id="cb2-18"><a href="#cb2-18"></a>        ans-=(sum[y]-ave)*(sum[y]-ave); ans+=(sum[y]+a[x]-ave)*(sum[y]+a[x]-ave);</span>
<span id="cb2-19"><a href="#cb2-19"></a>         <span class="cf">if</span>(rand()%<span class="dv">10000</span>+<span class="dv">1</span>&gt;T&amp;&amp;ans&gt;pre)ans=pre;<span class="cf">else</span> sum[pos[x]]-=a[x],sum[y]+=a[x],pos[x]=y;</span>
<span id="cb2-20"><a href="#cb2-20"></a>         T*=<span class="fl">0.9</span>;</span>
<span id="cb2-21"><a href="#cb2-21"></a>     }</span>
<span id="cb2-22"><a href="#cb2-22"></a>     <span class="cf">if</span>(ans&lt;mn)mn=ans;</span>
<span id="cb2-23"><a href="#cb2-23"></a>}</span>
<span id="cb2-24"><a href="#cb2-24"></a><span class="dt">int</span> main(){</span>
<span id="cb2-25"><a href="#cb2-25"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%lf</span><span class="st">&quot;</span>,&amp;a[i]),ave+=a[i],swap(a[i],a[rand()%i+<span class="dv">1</span>]);</span>
<span id="cb2-26"><a href="#cb2-26"></a>    ave/=(<span class="dt">double</span>)m; mn=INF; inc(i,<span class="dv">1</span>,<span class="dv">5000</span>)solve();</span>
<span id="cb2-27"><a href="#cb2-27"></a>    printf(<span class="st">&quot;%.2lf&quot;</span>,sqrt(mn/(<span class="dt">double</span>)m));</span>
<span id="cb2-28"><a href="#cb2-28"></a>}</span></code></pre></div>
<footer>
    <hr><center>转载请注明出处<br>© 2023 VnYzm的博客</center>
</footer>
</body>
</html>
