<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN" data-theme="tufte">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/extra/classless.css" />
<style>
html[data-theme='tufte']{
    --rem: 15px;
    --navpos: absolute;
    --width: 70rem;
    --font-p: 1.4rem/2 et-book, Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
    --font-h: 1.4rem/1.5 et-book, Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
    --font-c: .9em/1.4 Consolas,"Liberation Mono","Courier New",monospace;
    --ornament: "";
    --border: 1px solid var(--cmed);
    /* foreground   | background color */
    --cfg:   #111;    --cbg:    #fbf7ec;
    --cdark: #111;    --clight: #fbf7ec;
    --cmed: #b4d5fe;
    --clink: #111;
    --cemph: #111;
}
</style>
  <script>
      let search = () => {
          let word = document.querySelector('input');
          if (word.value.length == 0) {
              word.focus();
          } else {
              location.href = '/search.html?' + word.value;
          }
      };
      window.onload = () => {
          document.querySelector('input').addEventListener(
              'keydown',  (event) => {
                  if (event.key == 'Enter') search();
          });
      }
  </script>
  <link rel="icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <title>题解归档：2015年12月（点分治、动态树、树链剖分）</title>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <nav>
        <ul>
            <li><big>VnYzm的博客</big></li>
            <li><a href="/index.html">主页</a></li>
            <li><a href="/html/随笔.html">随笔</a></li>
            <li><a href="/miscellany.html">杂谈</a></li>
            <li class="float-right sticky"><button style="margin: 0" onclick="search()">Go</button></li>
            <li class="float-right sticky"><input type="search" placeholder="搜索" style="margin: 0"></li>
        </ul>
    </nav>
<header id="title-block-header">
<h1 class="title">题解归档：2015年12月（点分治、动态树、树链剖分）</h1>
<hr>
</header>
<h3 id="bzoj1468-tree2015.12.10">bzoj1468 Tree*（2015.12.10）</h3>
<h4 id="题意">题意</h4>
<p>给你一棵TREE,以及这棵树上边的距离.问有多少对点它们两者间的距离小于等于K。</p>
<h4 id="题解">题解</h4>
<p>点分治：先建树，然后分两步：</p>
<ol type="1">
<li>计算当前点所在子树中符合条件的点对</li>
<li>在当前点的子树中选一个点作为根节点，递归这些根结点</li>
</ol>
<p>如何求当前点所在子树中符合条件的点对数呢？先通过dfs求出从当前节点到所在子树各节点的距离，然后用排序+两头计算法计算出从某节点到当前节点再到另一节点的距离满足条件的点对。但是，这样做是有缺陷的：如图，当前节点为2，就可能求出4-5-2-5-6这样不存在的情况，怎么办呢？</p>
<p>设此点对数为x。我们可以对每个子节点进行这样的计算：将该子节点的初始距离数组d[x]置为当前节点到该子节点的距离，求出该子节点到其所在子树所有点的距离，然后用与刚才类似的方法算出与该子节点相关的点对数设为yi。将x减掉所有子节点的yi得到的值就是真实的点对数。刚才计算子节点的操作实际上求得的就是经过该子节点的不存在的点对数（如中间经过5-2-5的点对）。前面述说的两个操作类似，可以合并成一个函数getdis，前者操作就是把当前节点的初始距离数组d[x]置为0。具体看代码。</p>
<p>选哪个节点作为根节点？引入一个概念：树的重心：找到一个点,其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡。很明显，我们找根就要找树的重心。怎么求树的重心呢？用dfs求出当前节点所在子树的每个节点最大子树的最小值即可，注意树的形态是不一定的，所以除了逻辑上的儿子sz[i]还有sm-sz[x]。</p>
<p>同时还有一些细节，比如vis数组，使搜索时不要搜到想搜的子树之外的节点。时间复杂度？work执行n次，calc执行O(log2n)次（因为根为树的重心），getroot和getdis总共执行了O(nlog2n)次，所以总复杂度为O(nlog2n)（其实我也不知道为什么复杂度是这个，但它就是这个……）。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="pp">#define visit</span>(i,j)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=g[j];i!=-<span class="dv">1</span>;i=es[i].n)</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="pp">#define N </span><span class="dv">40010</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="dt">int</span> n,k,ans;</span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}; e es[N*<span class="dv">2</span>]; <span class="dt">int</span> ess,g[N];</span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="kw">inline</span> <span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){es[++ess]=(e){t,w,g[f]}; g[f]=ess; es[++ess]=(e){f,w,g[t]}; g[t]=ess;}</span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="dt">int</span> root,sm,mn,szs,d[N],sz[N],data[N]; <span class="dt">bool</span> vis[N];</span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="dt">void</span> getroot(<span class="dt">int</span> x,<span class="dt">int</span> fa){</span>
<span id="cb1-17"><a href="#cb1-17"></a>    sz[x]=<span class="dv">1</span>; <span class="dt">int</span> mx=<span class="dv">0</span>;</span>
<span id="cb1-18"><a href="#cb1-18"></a>    visit(i,x)<span class="cf">if</span>(! vis[es[i].t]&amp;&amp;es[i].t!=fa){getroot(es[i].t,x); sz[x]+=sz[es[i].t]; mx=max(mx,sz[es[i].t]);}</span>
<span id="cb1-19"><a href="#cb1-19"></a>    mx=max(mx,sm-sz[x]); <span class="cf">if</span>(mx&lt;mn)root=x,mn=mx;</span>
<span id="cb1-20"><a href="#cb1-20"></a>}</span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="dt">void</span> getdis(<span class="dt">int</span> x,<span class="dt">int</span> fa){</span>
<span id="cb1-22"><a href="#cb1-22"></a>    data[++szs]=d[x];</span>
<span id="cb1-23"><a href="#cb1-23"></a>    visit(i,x)<span class="cf">if</span>(! vis[es[i].t]&amp;&amp;es[i].t!=fa){d[es[i].t]=d[x]+es[i].w; getdis(es[i].t,x);}</span>
<span id="cb1-24"><a href="#cb1-24"></a>}</span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="dt">int</span> calc(<span class="dt">int</span> x,<span class="dt">int</span> st){</span>
<span id="cb1-26"><a href="#cb1-26"></a>    d[x]=st; szs=<span class="dv">0</span>; getdis(x,-<span class="dv">1</span>); sort(data+<span class="dv">1</span>,data+szs+<span class="dv">1</span>); <span class="dt">int</span> l=<span class="dv">1</span>,r=szs,a=<span class="dv">0</span>;</span>
<span id="cb1-27"><a href="#cb1-27"></a>    <span class="cf">while</span>(l&lt;r){<span class="cf">if</span>(data[l]+data[r]&lt;=k)a+=(r-l),l++;<span class="cf">else</span> r--;}</span>
<span id="cb1-28"><a href="#cb1-28"></a>    <span class="cf">return</span> a;</span>
<span id="cb1-29"><a href="#cb1-29"></a>}</span>
<span id="cb1-30"><a href="#cb1-30"></a><span class="dt">void</span> work(<span class="dt">int</span> x){</span>
<span id="cb1-31"><a href="#cb1-31"></a>    ans+=calc(x,<span class="dv">0</span>); vis[x]=<span class="dv">1</span>;</span>
<span id="cb1-32"><a href="#cb1-32"></a>    visit(i,x)<span class="cf">if</span>(!vis[es[i].t]){ans-=calc(es[i].t,es[i].w); root=es[i].t; sm=sz[es[i].t]; mn=INF; getroot(es[i].t,x); work(root);}</span>
<span id="cb1-33"><a href="#cb1-33"></a>}</span>
<span id="cb1-34"><a href="#cb1-34"></a></span>
<span id="cb1-35"><a href="#cb1-35"></a><span class="dt">int</span> main(){</span>
<span id="cb1-36"><a href="#cb1-36"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); ess=<span class="dv">0</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g));</span>
<span id="cb1-37"><a href="#cb1-37"></a>    inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> a,b,c; scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;c); pe(a,b,c);} scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;k);</span>
<span id="cb1-38"><a href="#cb1-38"></a>    memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); root=<span class="dv">1</span>; mn=INF; getroot(<span class="dv">1</span>,-<span class="dv">1</span>); ans=<span class="dv">0</span>; work(root); printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,ans);</span>
<span id="cb1-39"><a href="#cb1-39"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-40"><a href="#cb1-40"></a>}</span></code></pre></div>
<h3 id="bzoj2157旅游2015.12.15">bzoj2157旅游（2015.12.15）</h3>
<h4 id="题意-1">题意</h4>
<p>给定有权树，支持单边权修改，路径边权取相反数，路径边权求和，路径边权求最大最小值。</p>
<h4 id="题解-1">题解</h4>
<p>用link-cut tree（lct）。link-cut tree与树链剖分有些类似，都是用某种数据结构维护树链。但也有很大差异：树链剖分是依据子树节点数确定轻重边，一经确定，不能更改，所以用相对静态的线段树维护，常数也较小。而link-cut tree是用来求解动态树问题的，它的链随时可以改变，因此也只能用动态的splay来维护，常数较大。</p>
<p>注意：本数据结构中splay是以节点在lct中的深度为关键字确定顺序的。lct中节点的fa有两个意思，当它不为自己所在splay的根结点时，fa表示其在splay中的父节点，当它为splay中的根节点时，fa表示这整条树链在lct中的父亲节点。</p>
<p>lct有三个基础操作：</p>
<ul>
<li>access(u)：使节点到根节点连成一条链，并把链上的分支断开。注意access过程就是不停的把节点旋到splay顶，将它与它的fa（即树链在lct中的fa）连接起来，因为是连接成一个splay，所以其fa节点的c[fa][1]也要修改并update</li>
<li>link(u,v)：将u所在lct连到v所在lct。先access(u)，再splay(u)，此时u的fa就是u所在lct的fa，将u的fa置为v就行了</li>
<li>cut(u)：将u从它所在的lct中脱离。先access(u),再splay(u)，此时u的左子节点就是lct上它的实际父亲，将它切了就行。因为是涉及splay的切除，所以c[u][0]也要修改并update</li>
</ul>
<p>可是有了这些怎么得到或更新任意两点间的信息呢？我们知道，求两点间的信息一般都要求lca，lct怎么会没这个功能呢？求u,v的lca：先access(u)，再access(v)，后者在执行的时候最后得到那个t（见程序）就是lca，因为之前x已经和根节点相连了。两次access后，再splay(u)，就形成一条从u连到lca且以u为根的树链，此时将u的信息与lca的右子节点信息合并即可。</p>
<p>吐槽：我是傻叉，rotate顺序写乱了，导致fa信息出错死循环re了3发，然后又因为两次access后没有splay又wa了2发，大样例调不出，自己的小样例又测不出错误，花了3h……</p>
<p>发现一个技巧，要让gdb在满足条件时停下来，可以if(条件满足)函数();然后在函数里设断点，就能准确中断了。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="pp">#define N </span><span class="dv">20010</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="co">//general</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="dt">int</span> n,m;</span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="dt">void</span> debug(){</span>
<span id="cb2-12"><a href="#cb2-12"></a>    n=n;</span>
<span id="cb2-13"><a href="#cb2-13"></a>}</span>
<span id="cb2-14"><a href="#cb2-14"></a></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="co">//edge</span></span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}; e es[N*<span class="dv">2</span>]; <span class="dt">int</span> ess,g[N];</span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){es[++ess]=(e){t,w,g[f]}; g[f]=ess; es[++ess]=(e){f,w,g[t]}; g[t]=ess;}</span>
<span id="cb2-18"><a href="#cb2-18"></a></span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="co">//splay</span></span>
<span id="cb2-20"><a href="#cb2-20"></a><span class="dt">int</span> fa[N]<span class="co">/*点的父亲，包括在splay中的父亲和所在splay的父亲*/,c[N][2]/*splay中的儿子节点*/</span>;</span>
<span id="cb2-21"><a href="#cb2-21"></a><span class="dt">int</span> sm[N],mx[N],mn[N],v[N],<span class="co">/*区间维护信息*/</span>dt[N],dts<span class="co">/*中间过程用*/</span>; <span class="dt">bool</span> tg[N]<span class="co">/*标记*/</span>;</span>
<span id="cb2-22"><a href="#cb2-22"></a><span class="kw">inline</span> <span class="dt">bool</span> is_root(<span class="dt">int</span> x){<span class="cf">return</span> fa[x]==<span class="dv">0</span>||(c[fa[x]][<span class="dv">0</span>]!=x&amp;&amp;c[fa[x]][<span class="dv">1</span>]!=x);}<span class="co">//判断是否为所在splay的根节点</span></span>
<span id="cb2-23"><a href="#cb2-23"></a><span class="dt">void</span> pushdown(<span class="dt">int</span> x){<span class="co">//标记下传。注：本程序中的标记表明本节点已更新子孙未更新</span></span>
<span id="cb2-24"><a href="#cb2-24"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>)<span class="cf">return</span>;</span>
<span id="cb2-25"><a href="#cb2-25"></a>    <span class="cf">if</span>(tg[x]){</span>
<span id="cb2-26"><a href="#cb2-26"></a>        <span class="dt">int</span> l=c[x][<span class="dv">0</span>],r=c[x][<span class="dv">1</span>]; tg[x]^=<span class="dv">1</span>;</span>
<span id="cb2-27"><a href="#cb2-27"></a>        <span class="cf">if</span>(l){tg[l]^=<span class="dv">1</span>; v[l]=-v[l]; sm[l]=-sm[l]; <span class="dt">int</span> t=mx[l]; mx[l]=-mn[l]; mn[l]=-t;}</span>
<span id="cb2-28"><a href="#cb2-28"></a>        <span class="cf">if</span>(r){tg[r]^=<span class="dv">1</span>; v[r]=-v[r]; sm[r]=-sm[r]; <span class="dt">int</span> t=mx[r]; mx[r]=-mn[r]; mn[r]=-t;}</span>
<span id="cb2-29"><a href="#cb2-29"></a>    }</span>
<span id="cb2-30"><a href="#cb2-30"></a>}</span>
<span id="cb2-31"><a href="#cb2-31"></a><span class="dt">void</span> update(<span class="dt">int</span> x){</span>
<span id="cb2-32"><a href="#cb2-32"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>)<span class="cf">return</span>;</span>
<span id="cb2-33"><a href="#cb2-33"></a>    <span class="dt">int</span> l=c[x][<span class="dv">0</span>],r=c[x][<span class="dv">1</span>]; sm[x]=v[x]+sm[l]+sm[r]; mx[x]=max(v[x],max(mx[l],mx[r])); mn[x]=min(v[x],min(mn[l],mn[r]));</span>
<span id="cb2-34"><a href="#cb2-34"></a>}</span>
<span id="cb2-35"><a href="#cb2-35"></a><span class="dt">void</span> rotate(<span class="dt">int</span> x){<span class="co">//旋转</span></span>
<span id="cb2-36"><a href="#cb2-36"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>||is_root(x))<span class="cf">return</span>;</span>
<span id="cb2-37"><a href="#cb2-37"></a>    <span class="dt">int</span> a=fa[x],b=fa[fa[x]]; <span class="dt">bool</span> d=c[a][<span class="dv">1</span>]==x,e=c[b][<span class="dv">1</span>]==a;</span>
<span id="cb2-38"><a href="#cb2-38"></a>    <span class="cf">if</span>(! is_root(a))c[b][e]=x;<span class="co">//注意在调用is_root前不能动参数的fa[a]和c[fa[a]][0]c[fa[a]][1]，不然会导致错误结果</span></span>
<span id="cb2-39"><a href="#cb2-39"></a>    <span class="cf">if</span>(c[x][!d])fa[c[x][!d]]=a;<span class="co">//注意别漏</span></span>
<span id="cb2-40"><a href="#cb2-40"></a>    fa[x]=b; fa[a]=x; c[a][d]=c[x][!d]; c[x][!d]=a;<span class="co">//注意修改的相对顺序</span></span>
<span id="cb2-41"><a href="#cb2-41"></a>    update(a); update(x); <span class="cf">if</span>(! is_root(x))update(b);</span>
<span id="cb2-42"><a href="#cb2-42"></a>}</span>
<span id="cb2-43"><a href="#cb2-43"></a><span class="dt">void</span> splay(<span class="dt">int</span> x){<span class="co">//伸展</span></span>
<span id="cb2-44"><a href="#cb2-44"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>)<span class="cf">return</span>;</span>
<span id="cb2-45"><a href="#cb2-45"></a>    dts=<span class="dv">0</span>; <span class="dt">int</span> t=x;</span>
<span id="cb2-46"><a href="#cb2-46"></a>    <span class="cf">while</span>(! is_root(t))dt[++dts]=t,t=fa[t]; dt[++dts]=t;<span class="co">//将根结点到x的所有标记一次下传</span></span>
<span id="cb2-47"><a href="#cb2-47"></a>    <span class="cf">while</span>(dts)pushdown(dt[dts]),dts--;</span>
<span id="cb2-48"><a href="#cb2-48"></a>    <span class="cf">while</span>(! is_root(x)){</span>
<span id="cb2-49"><a href="#cb2-49"></a>        <span class="cf">if</span>(!is_root(fa[x])) (c[fa[x]][<span class="dv">1</span>]==x)^(c[fa[fa[x]]][<span class="dv">1</span>]==fa[x])?rotate(x):rotate(fa[x]);</span>
<span id="cb2-50"><a href="#cb2-50"></a>        rotate(x);</span>
<span id="cb2-51"><a href="#cb2-51"></a>    }</span>
<span id="cb2-52"><a href="#cb2-52"></a>}</span>
<span id="cb2-53"><a href="#cb2-53"></a></span>
<span id="cb2-54"><a href="#cb2-54"></a><span class="co">//lct</span></span>
<span id="cb2-55"><a href="#cb2-55"></a><span class="dt">int</span> access(<span class="dt">int</span> x){<span class="co">//lct基本操作，使节点到根节点连成一条链，并把链上的分支断开</span></span>
<span id="cb2-56"><a href="#cb2-56"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-57"><a href="#cb2-57"></a>    <span class="dt">int</span> t=<span class="dv">0</span>;</span>
<span id="cb2-58"><a href="#cb2-58"></a>    <span class="cf">while</span>(x){</span>
<span id="cb2-59"><a href="#cb2-59"></a>        splay(x); c[x][<span class="dv">1</span>]=t; <span class="cf">if</span>(t)fa[t]=x;</span>
<span id="cb2-60"><a href="#cb2-60"></a>        update(x); t=x; x=fa[x];</span>
<span id="cb2-61"><a href="#cb2-61"></a>    }</span>
<span id="cb2-62"><a href="#cb2-62"></a>    debug();</span>
<span id="cb2-63"><a href="#cb2-63"></a>    <span class="cf">return</span> t;</span>
<span id="cb2-64"><a href="#cb2-64"></a>}</span>
<span id="cb2-65"><a href="#cb2-65"></a><span class="dt">void</span> link(<span class="dt">int</span> x,<span class="dt">int</span> y){<span class="co">//lct基本操作，本程序不用</span></span>
<span id="cb2-66"><a href="#cb2-66"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>||y==<span class="dv">0</span>)<span class="cf">return</span>;</span>
<span id="cb2-67"><a href="#cb2-67"></a>    access(x); splay(x); fa[x]=y;</span>
<span id="cb2-68"><a href="#cb2-68"></a>}</span>
<span id="cb2-69"><a href="#cb2-69"></a><span class="dt">void</span> cut(<span class="dt">int</span> x){<span class="co">//lct基本操作，本程序不用</span></span>
<span id="cb2-70"><a href="#cb2-70"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>)<span class="cf">return</span>;</span>
<span id="cb2-71"><a href="#cb2-71"></a>    access(x); splay(x); <span class="cf">if</span>(c[x][<span class="dv">0</span>])fa[c[x][<span class="dv">0</span>]]=<span class="dv">0</span>; c[x][<span class="dv">0</span>]=<span class="dv">0</span>; update(x);</span>
<span id="cb2-72"><a href="#cb2-72"></a>}</span>
<span id="cb2-73"><a href="#cb2-73"></a></span>
<span id="cb2-74"><a href="#cb2-74"></a><span class="co">//command</span></span>
<span id="cb2-75"><a href="#cb2-75"></a><span class="co">//注意修改时要根据题目要求将修改查询边权变为程序中的修改查询点权</span></span>
<span id="cb2-76"><a href="#cb2-76"></a><span class="dt">void</span> change(<span class="dt">int</span> x,<span class="dt">int</span> val){<span class="co">//更新权值</span></span>
<span id="cb2-77"><a href="#cb2-77"></a>    splay(x); v[x]=val; update(x);</span>
<span id="cb2-78"><a href="#cb2-78"></a>}</span>
<span id="cb2-79"><a href="#cb2-79"></a><span class="dt">void</span> rever(<span class="dt">int</span> x,<span class="dt">int</span> y){<span class="co">//反转</span></span>
<span id="cb2-80"><a href="#cb2-80"></a>    access(x); <span class="dt">int</span> a=access(y); <span class="co">/*别*/</span>splay(x);<span class="co">/*漏！下同*/</span></span>
<span id="cb2-81"><a href="#cb2-81"></a>    <span class="cf">if</span>(x==a){</span>
<span id="cb2-82"><a href="#cb2-82"></a>        <span class="dt">int</span> r=c[x][<span class="dv">1</span>]; tg[r]^=<span class="dv">1</span>; v[r]=-v[r]; sm[r]=-sm[r]; <span class="dt">int</span> t=mx[r]; mx[r]=-mn[r]; mn[r]=-t; update(x);</span>
<span id="cb2-83"><a href="#cb2-83"></a>    }<span class="cf">else</span>{</span>
<span id="cb2-84"><a href="#cb2-84"></a>        tg[x]^=<span class="dv">1</span>; v[x]=-v[x]; sm[x]=-sm[x]; <span class="dt">int</span> t=mx[x]; mx[x]=-mn[x]; mn[x]=-t;</span>
<span id="cb2-85"><a href="#cb2-85"></a>        <span class="dt">int</span> r=c[a][<span class="dv">1</span>]; tg[r]^=<span class="dv">1</span>; v[r]=-v[r]; sm[r]=-sm[r]; t=mx[r]; mx[r]=-mn[r]; mn[r]=-t;</span>
<span id="cb2-86"><a href="#cb2-86"></a>        update(a);</span>
<span id="cb2-87"><a href="#cb2-87"></a>    }</span>
<span id="cb2-88"><a href="#cb2-88"></a>}</span>
<span id="cb2-89"><a href="#cb2-89"></a><span class="dt">int</span> querysum(<span class="dt">int</span> x,<span class="dt">int</span> y){<span class="co">//求和</span></span>
<span id="cb2-90"><a href="#cb2-90"></a>    access(x); <span class="dt">int</span> a=access(y); splay(x);</span>
<span id="cb2-91"><a href="#cb2-91"></a>    <span class="cf">if</span>(x==a)<span class="cf">return</span> sm[c[x][<span class="dv">1</span>]];<span class="cf">else</span> <span class="cf">return</span> sm[x]+sm[c[a][<span class="dv">1</span>]];</span>
<span id="cb2-92"><a href="#cb2-92"></a>}</span>
<span id="cb2-93"><a href="#cb2-93"></a><span class="dt">int</span> querymax(<span class="dt">int</span> x,<span class="dt">int</span> y){<span class="co">//求最大值</span></span>
<span id="cb2-94"><a href="#cb2-94"></a>    access(x); <span class="dt">int</span> a=access(y); splay(x);</span>
<span id="cb2-95"><a href="#cb2-95"></a>    <span class="cf">if</span>(x==a)<span class="cf">return</span> mx[c[x][<span class="dv">1</span>]];<span class="cf">else</span> <span class="cf">return</span> max(mx[x],mx[c[a][<span class="dv">1</span>]]);</span>
<span id="cb2-96"><a href="#cb2-96"></a>}</span>
<span id="cb2-97"><a href="#cb2-97"></a><span class="dt">int</span> querymin(<span class="dt">int</span> x,<span class="dt">int</span> y){<span class="co">//求最小值</span></span>
<span id="cb2-98"><a href="#cb2-98"></a>    access(x); <span class="dt">int</span> a=access(y); splay(x);</span>
<span id="cb2-99"><a href="#cb2-99"></a>    <span class="cf">if</span>(x==a)<span class="cf">return</span> mn[c[x][<span class="dv">1</span>]];<span class="cf">else</span> <span class="cf">return</span> min(mn[x],mn[c[a][<span class="dv">1</span>]]);</span>
<span id="cb2-100"><a href="#cb2-100"></a>}</span>
<span id="cb2-101"><a href="#cb2-101"></a></span>
<span id="cb2-102"><a href="#cb2-102"></a><span class="dt">int</span> num[N];</span>
<span id="cb2-103"><a href="#cb2-103"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x){<span class="co">//建树，并将边权转为点权 ，本程序用边的终点点权表示这条边的边权</span></span>
<span id="cb2-104"><a href="#cb2-104"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x]){</span>
<span id="cb2-105"><a href="#cb2-105"></a>        fa[es[i].t]=x; v[es[i].t]=sm[es[i].t]=mx[es[i].t]=mn[es[i].t]=es[i].w; dfs(es[i].t);</span>
<span id="cb2-106"><a href="#cb2-106"></a>    }</span>
<span id="cb2-107"><a href="#cb2-107"></a>}</span>
<span id="cb2-108"><a href="#cb2-108"></a><span class="dt">int</span> main(){</span>
<span id="cb2-109"><a href="#cb2-109"></a>    <span class="co">//freopen(&quot;big.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;big.out&quot;,&quot;w&quot;,stdout);</span></span>
<span id="cb2-110"><a href="#cb2-110"></a>    memset(num,<span class="dv">0</span>,<span class="kw">sizeof</span>(num)); ess=<span class="dv">0</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g)); memset(fa,<span class="dv">0</span>,<span class="kw">sizeof</span>(fa));</span>
<span id="cb2-111"><a href="#cb2-111"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> a,b,c; scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;c); pe(a+<span class="dv">1</span>,b+<span class="dv">1</span>,c); num[i]=b+<span class="dv">1</span>;}</span>
<span id="cb2-112"><a href="#cb2-112"></a>    dfs(<span class="dv">1</span>);</span>
<span id="cb2-113"><a href="#cb2-113"></a>    memset(c,<span class="dv">0</span>,<span class="kw">sizeof</span>(c)); memset(tg,<span class="dv">0</span>,<span class="kw">sizeof</span>(tg)); mn[<span class="dv">0</span>]=INF; mx[<span class="dv">0</span>]=-INF; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;m); <span class="dt">char</span> s[<span class="dv">10</span>];</span>
<span id="cb2-114"><a href="#cb2-114"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb2-115"><a href="#cb2-115"></a>        <span class="dt">int</span> a,b; scanf(<span class="st">&quot;</span><span class="sc">%s%d%d</span><span class="st">&quot;</span>,s,&amp;a,&amp;b);</span>
<span id="cb2-116"><a href="#cb2-116"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;C&#39;</span>)change(num[a],b);</span>
<span id="cb2-117"><a href="#cb2-117"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;N&#39;</span>)a++,b++,rever(a,b);</span>
<span id="cb2-118"><a href="#cb2-118"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;S&#39;</span>)a++,b++,printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,querysum(a,b));</span>
<span id="cb2-119"><a href="#cb2-119"></a>        <span class="cf">if</span>(s[<span class="dv">1</span>]==<span class="ch">&#39;A&#39;</span>)a++,b++,printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,querymax(a,b));</span>
<span id="cb2-120"><a href="#cb2-120"></a>        <span class="cf">if</span>(s[<span class="dv">1</span>]==<span class="ch">&#39;I&#39;</span>)a++,b++,printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,querymin(a,b));</span>
<span id="cb2-121"><a href="#cb2-121"></a>    }</span>
<span id="cb2-122"><a href="#cb2-122"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-123"><a href="#cb2-123"></a>}</span></code></pre></div>
<h4 id="更新">2015.12.18更新</h4>
<p>用树链剖分重写一下本题。树链剖分主要分3个步骤：</p>
<ol type="1">
<li>第一次dfs，求出各节点的子树大小、权值、深度等信息。</li>
<li>第二次dfs，求出各节点所在树链的头，以及各节点的中儿子、在所有树链依次相连组成的大链中的位置</li>
<li>将所有树链依次相连组成的大链建成一棵全局线段树</li>
</ol>
<p>如何求lca(u,v)？不停循环这样一个过程：u和v哪个深度大，就让它向上爬一条重链再爬一条轻边，直到两个所在链头节点相等（即在同一条树链）。此时，深度小的那个就是lca。</p>
<p>如何维护（查询）(u,v)之间信息？求lca(u,v)，然后对u不停循环这个过程：维护u到所在树链头的信息，接着u爬一条重链再一条轻边，直到树链头深度小于lca（此时u与lca在同一条树链），然后维护u到lca的信息。对v重复相同操作。</p>
<p>程序中我之所以存了每个节点的重儿子，是因为题意求边权，根据我的程序中边权与点权的转换方式，lca的权值不能被维护（查询），所以“维护u到lca的信息”就变成“维护u到lca重儿子的信息（如果此时u=lca，不能执行此操作）”</p>
<p>吐槽：线段树真耗空间，开的数组大小必须是点数的4倍！因为这个我re了5发。同时线段树的pushdown是边查询（修改）边执行的，需要注意。</p>
<p>对比链剖和link-cut tree，发现lct完胜！？不管在代码长度还是时间空间复杂度上都是lct更优。不是说线段树的常数比splay小得多吗？个人认为链剖输在一下几个方面：</p>
<ul>
<li>链剖编程复杂度高，线段树要写一堆操作，链剖本身还要写一堆操作，同时链剖的操作还要写两个循环，大大增大了代码长度。</li>
<li>链剖空间复杂度高，4倍点数。这也是引起速度慢的一个重要原因，开大数组在一定程度上会增大程序的耗时。</li>
</ul>
<p>总结：本题数据不是很大，链剖的适用范围应该是数据比较大的题，因为此时对程序本身常数的要求要高过空间引起的常数。</p>
<p>根本原因：我太弱了，肯定是我链剖写残才会这么慢！</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="pp">#define N </span><span class="dv">20010</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="co">//gerneral</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="dt">int</span> n,m;</span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">//edge</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}; e es[N*<span class="dv">2</span>]; <span class="dt">int</span> ess,g[N];</span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="kw">inline</span> <span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){es[++ess]=(e){t,w,g[f]}; g[f]=ess; es[++ess]=(e){f,w,g[t]}; g[t]=ess;}</span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="co">//segment tree</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="dt">int</span> sm[N*<span class="dv">4</span>],mx[N*<span class="dv">4</span>],mn[N*<span class="dv">4</span>]<span class="co">/*节点信息*/</span>,v[N][<span class="dv">2</span>]<span class="co">/*中间数组*/</span>,l[N*<span class="dv">4</span>],r[N*<span class="dv">4</span>]<span class="co">/*区间*/</span>;</span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="dt">int</span> lc[N*<span class="dv">4</span>],rc[N*<span class="dv">4</span>]<span class="co">/*左右儿子*/</span>; <span class="dt">bool</span> tg[N*<span class="dv">4</span>]<span class="co">/*标记*/</span>;</span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="dt">void</span> update(<span class="dt">int</span> x){</span>
<span id="cb3-20"><a href="#cb3-20"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>)<span class="cf">return</span>;</span>
<span id="cb3-21"><a href="#cb3-21"></a>    sm[x]=sm[lc[x]]+sm[rc[x]]; mx[x]=max(mx[lc[x]],mx[rc[x]]); mn[x]=min(mn[lc[x]],mn[rc[x]]);</span>
<span id="cb3-22"><a href="#cb3-22"></a>}</span>
<span id="cb3-23"><a href="#cb3-23"></a><span class="dt">void</span> pushdown(<span class="dt">int</span> x){<span class="co">//标记意义同lct</span></span>
<span id="cb3-24"><a href="#cb3-24"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>||!tg[x])<span class="cf">return</span>; <span class="dt">int</span> L=lc[x],R=rc[x]; tg[x]^=<span class="dv">1</span>;</span>
<span id="cb3-25"><a href="#cb3-25"></a>    <span class="cf">if</span>(L){tg[L]^=<span class="dv">1</span>; sm[L]=-sm[L]; <span class="dt">int</span> t=mx[L]; mx[L]=-mn[L]; mn[L]=-t;}</span>
<span id="cb3-26"><a href="#cb3-26"></a>    <span class="cf">if</span>(R){tg[R]^=<span class="dv">1</span>; sm[R]=-sm[R]; <span class="dt">int</span> t=mx[R]; mx[R]=-mn[R]; mn[R]=-t;}</span>
<span id="cb3-27"><a href="#cb3-27"></a>}</span>
<span id="cb3-28"><a href="#cb3-28"></a><span class="dt">void</span> build(<span class="dt">int</span> x,<span class="dt">int</span> L,<span class="dt">int</span> R){<span class="co">//建线段树</span></span>
<span id="cb3-29"><a href="#cb3-29"></a>    l[x]=L; r[x]=R;</span>
<span id="cb3-30"><a href="#cb3-30"></a>    <span class="cf">if</span>(L==R)sm[x]=mx[x]=mn[x]=v[L][<span class="dv">1</span>],lc[x]=rc[x]=tg[x]=<span class="dv">0</span>;<span class="cf">else</span>{</span>
<span id="cb3-31"><a href="#cb3-31"></a>        <span class="dt">int</span> M=(L+R)&gt;&gt;<span class="dv">1</span>; lc[x]=x&lt;&lt;<span class="dv">1</span>; rc[x]=x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>; build(lc[x],L,M); build(rc[x],M+<span class="dv">1</span>,R); tg[x]=<span class="dv">0</span>; update(x);</span>
<span id="cb3-32"><a href="#cb3-32"></a>    }</span>
<span id="cb3-33"><a href="#cb3-33"></a>}</span>
<span id="cb3-34"><a href="#cb3-34"></a><span class="dt">void</span> change(<span class="dt">int</span> x,<span class="dt">int</span> nod,<span class="dt">int</span> val){<span class="co">//线段树点修改</span></span>
<span id="cb3-35"><a href="#cb3-35"></a>    pushdown(x);</span>
<span id="cb3-36"><a href="#cb3-36"></a>    <span class="cf">if</span>(l[x]==r[x])sm[x]=mx[x]=mn[x]=val;<span class="cf">else</span>{</span>
<span id="cb3-37"><a href="#cb3-37"></a>        <span class="dt">int</span> M=(l[x]+r[x])&gt;&gt;<span class="dv">1</span>; nod&lt;=M?change(lc[x],nod,val):change(rc[x],nod,val); update(x);</span>
<span id="cb3-38"><a href="#cb3-38"></a>    }</span>
<span id="cb3-39"><a href="#cb3-39"></a>}</span>
<span id="cb3-40"><a href="#cb3-40"></a><span class="dt">void</span> rever(<span class="dt">int</span> x,<span class="dt">int</span> ql,<span class="dt">int</span> qr){<span class="co">//线段树区间修改</span></span>
<span id="cb3-41"><a href="#cb3-41"></a>    pushdown(x);</span>
<span id="cb3-42"><a href="#cb3-42"></a>    <span class="dt">int</span> M=(l[x]+r[x])&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(ql&lt;=l[x]&amp;&amp;r[x]&lt;=qr){tg[x]^=<span class="dv">1</span>; sm[x]=-sm[x]; <span class="dt">int</span> t=mx[x]; mx[x]=-mn[x]; mn[x]=-t; <span class="cf">return</span>;}</span>
<span id="cb3-43"><a href="#cb3-43"></a>    <span class="cf">if</span>(ql&lt;=M)rever(lc[x],ql,qr); <span class="cf">if</span>(qr&gt;M)rever(rc[x],ql,qr); update(x);</span>
<span id="cb3-44"><a href="#cb3-44"></a>}</span>
<span id="cb3-45"><a href="#cb3-45"></a><span class="dt">int</span> querysum(<span class="dt">int</span> x,<span class="dt">int</span> ql,<span class="dt">int</span> qr){<span class="co">//线段树求和</span></span>
<span id="cb3-46"><a href="#cb3-46"></a>    pushdown(x);</span>
<span id="cb3-47"><a href="#cb3-47"></a>    <span class="dt">int</span> ret=<span class="dv">0</span>,M=(l[x]+r[x])&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(ql&lt;=l[x]&amp;&amp;r[x]&lt;=qr)<span class="cf">return</span> sm[x];</span>
<span id="cb3-48"><a href="#cb3-48"></a>    <span class="cf">if</span>(ql&lt;=M)ret+=querysum(lc[x],ql,qr); <span class="cf">if</span>(qr&gt;M)ret+=querysum(rc[x],ql,qr);</span>
<span id="cb3-49"><a href="#cb3-49"></a>    <span class="cf">return</span> ret;</span>
<span id="cb3-50"><a href="#cb3-50"></a>}</span>
<span id="cb3-51"><a href="#cb3-51"></a><span class="dt">int</span> querymax(<span class="dt">int</span> x,<span class="dt">int</span> ql,<span class="dt">int</span> qr){<span class="co">//线段树求最大值</span></span>
<span id="cb3-52"><a href="#cb3-52"></a>    pushdown(x);</span>
<span id="cb3-53"><a href="#cb3-53"></a>    <span class="dt">int</span> ret=-INF,M=(l[x]+r[x])&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(ql&lt;=l[x]&amp;&amp;r[x]&lt;=qr)<span class="cf">return</span> mx[x];</span>
<span id="cb3-54"><a href="#cb3-54"></a>    <span class="cf">if</span>(ql&lt;=M)ret=max(ret,querymax(lc[x],ql,qr)); <span class="cf">if</span>(qr&gt;M)ret=max(ret,querymax(rc[x],ql,qr));</span>
<span id="cb3-55"><a href="#cb3-55"></a>    <span class="cf">return</span> ret;</span>
<span id="cb3-56"><a href="#cb3-56"></a>}</span>
<span id="cb3-57"><a href="#cb3-57"></a><span class="dt">int</span> querymin(<span class="dt">int</span> x,<span class="dt">int</span> ql,<span class="dt">int</span> qr){<span class="co">//线段树求最小值</span></span>
<span id="cb3-58"><a href="#cb3-58"></a>    pushdown(x);</span>
<span id="cb3-59"><a href="#cb3-59"></a>    <span class="dt">int</span> ret=INF,M=(l[x]+r[x])&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(ql&lt;=l[x]&amp;&amp;r[x]&lt;=qr)<span class="cf">return</span> mn[x];</span>
<span id="cb3-60"><a href="#cb3-60"></a>    <span class="cf">if</span>(ql&lt;=M)ret=min(ret,querymin(lc[x],ql,qr)); <span class="cf">if</span>(qr&gt;M)ret=min(ret,querymin(rc[x],ql,qr));</span>
<span id="cb3-61"><a href="#cb3-61"></a>    <span class="cf">return</span> ret;</span>
<span id="cb3-62"><a href="#cb3-62"></a>}</span>
<span id="cb3-63"><a href="#cb3-63"></a></span>
<span id="cb3-64"><a href="#cb3-64"></a><span class="co">//tree chain apart</span></span>
<span id="cb3-65"><a href="#cb3-65"></a><span class="dt">int</span> pos[N]<span class="co">/*点在线段树中位置*/</span>,top[N]<span class="co">/*树链头节点*/</span>,fa[N],sz[N]<span class="co">/*子树大小*/</span>,sgs,dep[N]<span class="co">/*深度*/,ps[N]/*重儿子*/</span>;</span>
<span id="cb3-66"><a href="#cb3-66"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x){<span class="co">//得到节点的父亲、子树大小、权值、深度</span></span>
<span id="cb3-67"><a href="#cb3-67"></a>    sz[x]=<span class="dv">1</span>;</span>
<span id="cb3-68"><a href="#cb3-68"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=<span class="dv">0</span>;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x]){</span>
<span id="cb3-69"><a href="#cb3-69"></a>        fa[es[i].t]=x; dep[es[i].t]=dep[x]+<span class="dv">1</span>; v[es[i].t][<span class="dv">0</span>]=es[i].w; dfs(es[i].t); sz[x]+=sz[es[i].t];</span>
<span id="cb3-70"><a href="#cb3-70"></a>    }</span>
<span id="cb3-71"><a href="#cb3-71"></a>}</span>
<span id="cb3-72"><a href="#cb3-72"></a><span class="dt">void</span> buildchain(<span class="dt">int</span> x,<span class="dt">int</span> tp<span class="co">/*当前节点所在树链头*/</span>){<span class="co">//通过子树大小构造树链</span></span>
<span id="cb3-73"><a href="#cb3-73"></a>    pos[x]=++sgs; v[sgs][<span class="dv">1</span>]=v[x][<span class="dv">0</span>]; top[x]=tp; ps[x]=<span class="dv">0</span>;</span>
<span id="cb3-74"><a href="#cb3-74"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=<span class="dv">0</span>;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x]){</span>
<span id="cb3-75"><a href="#cb3-75"></a>        <span class="cf">if</span>(sz[es[i].t]&gt;sz[ps[x]])ps[x]=es[i].t;</span>
<span id="cb3-76"><a href="#cb3-76"></a>    }</span>
<span id="cb3-77"><a href="#cb3-77"></a>    <span class="cf">if</span>(ps[x]==<span class="dv">0</span>)<span class="cf">return</span>;</span>
<span id="cb3-78"><a href="#cb3-78"></a>    buildchain(ps[x],tp);</span>
<span id="cb3-79"><a href="#cb3-79"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=<span class="dv">0</span>;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x]){</span>
<span id="cb3-80"><a href="#cb3-80"></a>        <span class="cf">if</span>(es[i].t!=ps[x])buildchain(es[i].t,es[i].t);</span>
<span id="cb3-81"><a href="#cb3-81"></a>    }</span>
<span id="cb3-82"><a href="#cb3-82"></a>}</span>
<span id="cb3-83"><a href="#cb3-83"></a><span class="dt">void</span> init(){</span>
<span id="cb3-84"><a href="#cb3-84"></a>    memset(fa,<span class="dv">0</span>,<span class="kw">sizeof</span>(fa)); dep[<span class="dv">1</span>]=<span class="dv">1</span>; dfs(<span class="dv">1</span>);</span>
<span id="cb3-85"><a href="#cb3-85"></a>    sgs=<span class="dv">0</span>; mx[<span class="dv">0</span>]=-INF; mn[<span class="dv">0</span>]=INF; sz[<span class="dv">0</span>]=<span class="dv">0</span>; buildchain(<span class="dv">1</span>,<span class="dv">1</span>); build(<span class="dv">1</span>,<span class="dv">1</span>,sgs);</span>
<span id="cb3-86"><a href="#cb3-86"></a>}</span>
<span id="cb3-87"><a href="#cb3-87"></a><span class="dt">int</span> lca(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb3-88"><a href="#cb3-88"></a>    <span class="cf">for</span>(;top[x]!=top[y];x=fa[top[x]]){<span class="cf">if</span>(dep[top[x]]&lt;dep[top[y]])swap(x,y);}</span>
<span id="cb3-89"><a href="#cb3-89"></a>    <span class="cf">return</span> dep[x]&lt;dep[y]?x:y;</span>
<span id="cb3-90"><a href="#cb3-90"></a>}</span>
<span id="cb3-91"><a href="#cb3-91"></a><span class="dt">void</span> solvechange(<span class="dt">int</span> x,<span class="dt">int</span> val){change(<span class="dv">1</span>,pos[x],val);}</span>
<span id="cb3-92"><a href="#cb3-92"></a><span class="dt">void</span> solverever(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb3-93"><a href="#cb3-93"></a>    <span class="cf">if</span>(x==y)<span class="cf">return</span>; <span class="dt">int</span> a=lca(x,y);</span>
<span id="cb3-94"><a href="#cb3-94"></a>    <span class="cf">while</span>(dep[top[x]]&gt;dep[a])rever(<span class="dv">1</span>,pos[top[x]],pos[x])<span class="co">/*注意参数顺序，下同*/</span>,x=fa[top[x]];</span>
<span id="cb3-95"><a href="#cb3-95"></a>    <span class="cf">if</span>(a!=x)rever(<span class="dv">1</span>,pos[ps[a]],pos[x]);</span>
<span id="cb3-96"><a href="#cb3-96"></a>    <span class="cf">while</span>(dep[top[y]]&gt;dep[a])rever(<span class="dv">1</span>,pos[top[y]],pos[y]),y=fa[top[y]];</span>
<span id="cb3-97"><a href="#cb3-97"></a>    <span class="cf">if</span>(a!=y)rever(<span class="dv">1</span>,pos[ps[a]],pos[y]);</span>
<span id="cb3-98"><a href="#cb3-98"></a>}</span>
<span id="cb3-99"><a href="#cb3-99"></a><span class="dt">int</span> solvesum(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb3-100"><a href="#cb3-100"></a>    <span class="cf">if</span>(x==y)<span class="cf">return</span> <span class="dv">0</span>; <span class="dt">int</span> a=lca(x,y),ans=<span class="dv">0</span>;</span>
<span id="cb3-101"><a href="#cb3-101"></a>    <span class="cf">while</span>(dep[top[x]]&gt;dep[a])ans+=querysum(<span class="dv">1</span>,pos[top[x]],pos[x]),x=fa[top[x]];</span>
<span id="cb3-102"><a href="#cb3-102"></a>    <span class="cf">if</span>(a!=x)ans+=querysum(<span class="dv">1</span>,pos[ps[a]],pos[x]);</span>
<span id="cb3-103"><a href="#cb3-103"></a>    <span class="cf">while</span>(dep[top[y]]&gt;dep[a])ans+=querysum(<span class="dv">1</span>,pos[top[y]],pos[y]),y=fa[top[y]];</span>
<span id="cb3-104"><a href="#cb3-104"></a>    <span class="cf">if</span>(a!=y)ans+=querysum(<span class="dv">1</span>,pos[ps[a]],pos[y]);</span>
<span id="cb3-105"><a href="#cb3-105"></a>    <span class="cf">return</span> ans;</span>
<span id="cb3-106"><a href="#cb3-106"></a>}</span>
<span id="cb3-107"><a href="#cb3-107"></a><span class="dt">int</span> solvemax(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb3-108"><a href="#cb3-108"></a>    <span class="cf">if</span>(x==y)<span class="cf">return</span> <span class="dv">0</span>; <span class="dt">int</span> a=lca(x,y),ans=-INF;</span>
<span id="cb3-109"><a href="#cb3-109"></a>    <span class="cf">while</span>(dep[top[x]]&gt;dep[a])ans=max(ans,querymax(<span class="dv">1</span>,pos[top[x]],pos[x])),x=fa[top[x]];</span>
<span id="cb3-110"><a href="#cb3-110"></a>    <span class="cf">if</span>(a!=x)ans=max(ans,querymax(<span class="dv">1</span>,pos[ps[a]],pos[x]));</span>
<span id="cb3-111"><a href="#cb3-111"></a>    <span class="cf">while</span>(dep[top[y]]&gt;dep[a])ans=max(ans,querymax(<span class="dv">1</span>,pos[top[y]],pos[y])),y=fa[top[y]];</span>
<span id="cb3-112"><a href="#cb3-112"></a>    <span class="cf">if</span>(a!=y)ans=max(ans,querymax(<span class="dv">1</span>,pos[ps[a]],pos[y]));</span>
<span id="cb3-113"><a href="#cb3-113"></a>    <span class="cf">return</span> ans;</span>
<span id="cb3-114"><a href="#cb3-114"></a>}</span>
<span id="cb3-115"><a href="#cb3-115"></a><span class="dt">int</span> solvemin(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb3-116"><a href="#cb3-116"></a>    <span class="cf">if</span>(x==y)<span class="cf">return</span> <span class="dv">0</span>; <span class="dt">int</span> a=lca(x,y),ans=INF;</span>
<span id="cb3-117"><a href="#cb3-117"></a>    <span class="cf">while</span>(dep[top[x]]&gt;dep[a])ans=min(ans,querymin(<span class="dv">1</span>,pos[top[x]],pos[x])),x=fa[top[x]];</span>
<span id="cb3-118"><a href="#cb3-118"></a>    <span class="cf">if</span>(a!=x)ans=min(ans,querymin(<span class="dv">1</span>,pos[ps[a]],pos[x]));</span>
<span id="cb3-119"><a href="#cb3-119"></a>    <span class="cf">while</span>(dep[top[y]]&gt;dep[a])ans=min(ans,querymin(<span class="dv">1</span>,pos[top[y]],pos[y])),y=fa[top[y]];</span>
<span id="cb3-120"><a href="#cb3-120"></a>    <span class="cf">if</span>(a!=y)ans=min(ans,querymin(<span class="dv">1</span>,pos[ps[a]],pos[y]));</span>
<span id="cb3-121"><a href="#cb3-121"></a>    <span class="cf">return</span> ans;</span>
<span id="cb3-122"><a href="#cb3-122"></a>}</span>
<span id="cb3-123"><a href="#cb3-123"></a></span>
<span id="cb3-124"><a href="#cb3-124"></a><span class="co">//main</span></span>
<span id="cb3-125"><a href="#cb3-125"></a><span class="dt">int</span> num[N];</span>
<span id="cb3-126"><a href="#cb3-126"></a><span class="dt">int</span> main(){</span>
<span id="cb3-127"><a href="#cb3-127"></a>    <span class="co">//freopen(&quot;zs.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;zs.out&quot;,&quot;w&quot;,stdout);</span></span>
<span id="cb3-128"><a href="#cb3-128"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g)); ess=<span class="dv">0</span>;</span>
<span id="cb3-129"><a href="#cb3-129"></a>    inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> a,b,c; scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;c); a++; b++; pe(a,b,c); num[i]=b;}</span>
<span id="cb3-130"><a href="#cb3-130"></a>    init(); scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;m); <span class="dt">char</span> s[<span class="dv">10</span>];</span>
<span id="cb3-131"><a href="#cb3-131"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb3-132"><a href="#cb3-132"></a>        <span class="dt">int</span> a,b; scanf(<span class="st">&quot;</span><span class="sc">%s%d%d</span><span class="st">&quot;</span>,s,&amp;a,&amp;b);</span>
<span id="cb3-133"><a href="#cb3-133"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;C&#39;</span>)solvechange(num[a],b);</span>
<span id="cb3-134"><a href="#cb3-134"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;N&#39;</span>)a++,b++,solverever(a,b);</span>
<span id="cb3-135"><a href="#cb3-135"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;S&#39;</span>)a++,b++,printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,solvesum(a,b));</span>
<span id="cb3-136"><a href="#cb3-136"></a>        <span class="cf">if</span>(s[<span class="dv">1</span>]==<span class="ch">&#39;A&#39;</span>)a++,b++,printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,solvemax(a,b));</span>
<span id="cb3-137"><a href="#cb3-137"></a>        <span class="cf">if</span>(s[<span class="dv">1</span>]==<span class="ch">&#39;I&#39;</span>)a++,b++,printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,solvemin(a,b));</span>
<span id="cb3-138"><a href="#cb3-138"></a>    }</span>
<span id="cb3-139"><a href="#cb3-139"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-140"><a href="#cb3-140"></a>}</span></code></pre></div>
<footer>
    <hr><center>转载请注明出处<br>© 2023 VnYzm的博客</center>
</footer>
</body>
</html>
